#!/bin/sh
depend_procedure core base # esp for auto_{network,locale,fstab} workers


# This is a port of the original /arch/setup script.  It doesn't use fifa phases but uses it's own menu-based flow (phase) control


TARGET_DIR="/mnt"
EDITOR=


# clock
HARDWARECLOCK=
TIMEZONE=

# partitions
PART_ROOT=

# default filesystem specs (the + is bootable flag)
# <mountpoint>:<partsize>:<fstype>[:+]
DEFAULTFS="/boot:32:ext2:+ swap:256:swap /:7500:ext3 /home:*:ext3"



start_process ()
{
	#####################
	## begin execution ##

	#TODO: implement check_depend everywhere
	#TODO: now that exit states of all workers are maintained by the execute function, we are getting rid of this special flow control

	# install stages
	S_SRC=0         # choose install medium
	S_NET=0         # network configuration
	S_CLOCK=0       # clock and timezone
	S_SELECT=0      # package selection
	S_INSTALL=0     # package installation
	S_CONFIG=0      # configuration editing
	S_GRUB=0        # TODO: kill this - if using grub
	S_BOOT=""       # bootloader installed

	var_UI_TYPE=dia

	notify "Welcome to the Arch Linux Installation program. The install \
	process is fairly straightforward, and you should run through the options in \
	the order they are presented. If you are unfamiliar with partitioning/making \
	filesystems, you may want to consult some documentation before continuing. \
	You can view all output from commands by viewing your VC7 console (ALT-F7). \
	ALT-F1 will bring you back here."

	# menu item tracker- autoselect the next item
	NEXTITEM=""
	
	while true
	do
    		mainmenu
	done

}


mainmenu()  
{
	default=no
	[ -n "$NEXTITEM" ] && default="$NEXTITEM"
	ask_option $default "MAIN MENU" \
	"0" "Select Source" \
	"1" "Set Clock" \
	"2" "Prepare Hard Drive" \
	"3" "Select Packages" \
	"4" "Install Packages" \
	"5" "Configure System" \
	"6" "Install Bootloader" \
	"7" "Exit Install"
	NEXTITEM="$ANSWER_OPTION" #TODO: set next item always current+1 after succesfull finish of each phase/worker, if relevant
	case $ANSWER_OPTION in
	"0")
		execute worker select_source; ret=$?
		if [ $ret -eq 0 -a "$var_PKG_SOURCE_TYPE" = "ftp" ]; then
			while true; do
				ask_option no "FTP Installation" \
				"0" "Setup Network (Make sure the network is ok before continuing" \
				"1" "Choose Mirror" \
				"2" "Return to Main Menu"
				[ "$ANSWER_OPTION" = 0 ] && execute worker runtime_network && S_NET=1
				[ "$ANSWER_OPTION" = 1 ] && execute worker select_mirror
				[ "$ANSWER_OPTION" = 2 ] && break
			done
		fi
		[ $ret -eq 0 ] && S_SRC=1 && execute worker runtime_packages ;;
        "1")
            execute worker set_clock && S_CLOCK=1 && NEXTITEM=2;;
        "2")
            execute worker prepare_disks && NEXTITEM=3;; # stage set vars set in the worker
        "3")
            check_depend worker prepare_disks && execute worker package_list && S_SELECT=1 && NEXTITEM=4 ;;
        "4")
            check_depend worker package_list && execute worker install_packages && S_INSTALL=1 && { execute worker auto_fstab; execute worker auto_network; execute worker auto_locale; } && NEXITITEM=5 ;; 
        "5")
            check_depend worker install_packages && execute worker configure_system && S_CONFIG=1 && { execute worker mkinitcpio; execute worker locales; } && NEXTITEM=6 ;;
        "6")
		 execute worker install_bootloader && S_BOOT=1 && NEXTITEM=7 ;;
        "7")
            notify "If the install finished successfully, you can now type 'reboot' to restart the system." && stop_installer ;;
        *)
            ask_yesno "Abort Installation?" && stop_installer ;;
    esac
}


worker_configure_system()
{
    ## PREPROCESSING ##
    # only done on first invocation of configure_system
    if [ $S_CONFIG -eq 0 ]; then

        # /etc/pacman.d/mirrorlist
        # add installer-selected mirror to the top of the mirrorlist
        if [ "$MODE" = "ftp" -a "${SYNC_URL}" != "" ]; then
            awk "BEGIN { printf(\"# Mirror used during installation\nServer = "${SYNC_URL}"\n\n\") } 1 " "${var_TARGET_DIR}/etc/pacman.d/mirrorlist"
        fi

        # /etc/rc.conf
        # insert timezone and utc info
        sed -i -e "s/^TIMEZONE=.*/TIMEZONE=\"$TIMEZONE\"/g" \
               -e "s/^HARDWARECLOCK=.*/HARDWARECLOCK=\"$HARDWARECLOCK\"/g" \
               ${var_TARGET_DIR}/etc/rc.conf
    fi


	interactive_configure_system &&	return 0
	return 1
}


worker_prepare_disks()
{
	DONE=0
	ret=1 # 1 means unsuccessful. 0 for ok
	NEXTITEM=
	DISK_CONFIG_TYPE=
    while [ "$DONE" = "0" ]; do
        if [ -n "$NEXTITEM" ]; then
            DEFAULT="--default-item $NEXTITEM"
        else
            DEFAULT=""
        fi
        _dia_DIALOG $DEFAULT --menu "Prepare Hard Drive" 12 60 5 \
            "1" "Auto-Prepare (erases the ENTIRE hard drive and sets up partitions and filesystems)" \
            "2" "Partition Hard Drives" \
            "3" "Set Filesystem Mountpoints" \
            "4" "Return to Main Menu" 2>$ANSWER
        NEXTITEM="$(cat $ANSWER)"
        case $(cat $ANSWER) in
            "1")
                interactive_autoprepare && NEXTITEM=4 && ret=0 && DISK_CONFIG_TYPE=auto;;
            "2")
		if [ "$DISK_CONFIG_TYPE" = "auto" ]; then
			notify "You have already prepared your filesystems with Auto-prepare" #TODO: allow user to do this anyway. he can change his mind.
		else
			interactive_partition && ret=1 && NEXTITEM=3 && DISK_CONFIG_TYPE=manual
		fi
		;;
            "3")
		PARTFINISH=""
		if "$DISK_CONFIG_TYPE" = "auto"  ]; then
			notify "You have already prepared your filesystems with Auto-prepare" #TODO: allow user to do this anyway. he can change his mind.
		else
			interactive_mountpoints && ret=0 && NEXTITEM=4 && DISK_CONFIG_TYPE=manual
		fi
		;;
            *)
                DONE=1 ;;
        esac
    done
    return $ret
}


# set_clock()
# prompts user to set hardware clock and timezone
#
# params: none
set_clock()   
{
	interactive_set_clock
}


worker_select_source ()
{
	#TODO: how to handle user going here again? discard previous settings, warn him that he already done it?
	interactive_select_source && return 0
	return 1
}



# select_packages()
# prompts the user to select packages to install
worker_package_list() {
    # step dependencies
    if [ $S_SRC -eq 0 ]; then
        _dia_DIALOG --msgbox "You must select an installation source!" 0 0
        return 1
    fi

    # if selection has been done before, warn about loss of input
    # and let the user exit gracefully
    if [ $S_SELECT -ne 0 ]; then
        _dia_DIALOG --yesno "WARNING: Running this stage again will result in the loss of previous package selections.\n\nDo you wish to continue?" 10 50 || return 1
    fi

	interactive_select_packages
}


worker_install_packages ()
{
	if [ $S_SELECT -eq 0 ]; then
		notify "You must select packages first."
		return 1
	fi
	installpkg && return 0
	return 1
}


# Hand-hold through setting up networking
worker_runtime_network() {
	interactive_runtime_network
}


dogrub() {
	interactive_dogrub && S_GRUB=1
}


worker_select_mirror ()
{
	interactive_select_mirror
}


worker_install_bootloader ()
{
	ask_option Grub "Which bootloader would you like to use?  Grub is the Arch default." \
			"Grub" "Use the GRUB bootloader (default)" \
			"None" "\Zb\Z1Warning\Z0\ZB: you must install your own bootloader!"

	bl=`tr '[:upper:]' '[:lower:]' <<< "$ANSWER_OPTION"`
	[ "$bl" != grub ] && return 0
	interactive_install_grub
}


worker_auto_network ()
{
	[ $S_NET -eq 0 ] && return 1

	ask_yesno "Do you want to use the network settings from the installer in rc.conf and resolv.conf?\n\nIf you used Proxy settings, they will be written to /etc/profile.d/proxy.sh" || return 1

        [ "$S_DHCP" = 1 ] && target_configure_network dhcp "$PROXY_HTTP" "$PROXY_FTP"
        [ "$S_DHCP" != 1 ] && target_configure_network fixed "$PROXY_HTTP" "$PROXY_FTP"
}
