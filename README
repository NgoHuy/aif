AIF is the Arch Linux Installation Framework..

---  Alpha software.  Use at own risk!! ---


Licensce:     GPL3. See COPYING.
Author:       Dieter Plaetinck
Homepage:     http://github.com/Dieterbe/aif


** Goals **
The goal of this project is 
1) to allow you to install Arch Linux in more flexible and powerful ways.
2) write an automated (unattended) installer
3) Apply DRY patterns to the installation procedure, making it more easy to maintain the code.


You can choose to use unattended (automatic) installation (you can write different
modules/procedures for different scenario's, and/or use autodetection) or prompt the user for whatever you want to know (you could mimic the official installer like
that).
You can also take parts from different installation procedures and combine them
together to come up with the procedure of your liking.


** File locations (on the install CD): **
Basically aif.sh is put in /arch (together with the default installer scripts), while all other aif-related files belong in /home/arch/aif

* aif.sh        -> /arch/aif
* docs          -> /home/arch/aif/docs/
* core module   -> /home/arch/aif/core
* user modules  -> /home/arch/aif/user/<module name> (put your own modules here)
* runtime files -> /home/arch/aif/runtime (package list etc go here)

A module can have 2 directories: libs, and procedures.

** Workflow **
There is a very basic but powerful workflow defined by variables, phases and workers.
Depending on the procedure you choose (or write yourself), these will differ
In the code, they are very recognizable and are named like this:
 - variable -> var_<foo>
 - phase    -> phase_<bar> (an array in which each element is a worker to be executed, with optionally arguments for that worker)
               There are 4 phases: preparation, basics, system, finish. (executed in that order)
 - worker   -> worker_<baz> ( a worker function, called by a phase. implements some specific logic.
               eg runtime_packages, prepare_disks, package_list etc)

You can depend on whatever procedure you like (like core/base), to save
yourself some work (you only need to override a few things)

Notes:
 - The phases are started by the start_process function.  You can also override this function to take flow control in your own hands (eg iterative, menu-based installer)
 - you _can_ override _all_ variables and functions in your modules, but you should be able to achieve your goals by
   overriding only the 3 basic things and the start_process function, and only in procedures.
 - you _must_ specify a procedure, to avoid errors. take 'interactive' if unsure
 - don't edit the base procedure (or any other core item), rather make your own. It's easy!
 - you're not supposed to define new phases. just override them. logic goes in workers/libariers

Modules are the building blocks in aif.  They can contain libraries (for
user interfaces, backend logic, etc) and procedures (how an installation
process should go).
The core module comes by default and contains everything 99% of the users
will need.  You can easily make your own modules with in it your own
procedures (and your own libraries, if you need that).  If you build your
own libraries, it's generally a good idea to keep
their names in line with what core has (lib-ui.sh, lib-network.sh etc). 
Do not put stuff in the core module yourself!  If it's good stuff, it might
be merged into core someday...  Also, don't name your custom module 'core' (it will be
ignored anyway).  Don't call it http either, because you can specify
'http://some/path/to/a/procedure', aif will download that procedure and
execute it (and the module will be 'http')

Note that if you load a module and a library has the same function names as
the core module, it will override the functions from core.
This means you can 'inject' new backend code into core procedures, but you
can also write your own procedures that use your own, or the core libraries.
If you load a module, you actually load it's libraries, not it's procedures!
Procedures are only loaded when needed (because you request them because
of dependencies)

If you need a library from another user contributed module, execute
'depend_module <modulename>' for each module.  This way you load all the
libs of that module (not the procedures, use depend_procedure for that. 
keep in mind that the position of the depend_procedure statement defines
where your variables/functions might be overridden...)
(very basic dependencies, no version checking etc)

You can specify a core procedure on the command line by specifying
'<procedure_name>', to specify a user contriubuted procedure, specify
'<module_name>/<procedure_name>'




** Procedures **
core/base:        basic, little-interactivity installation with some common defaults.  You probably don't
                  want to run this one, although it's useful for other procedures to inherit from.
core/interactive: interactive, reasonably flexible/featured installer (port of /arch/setup)
core/quickinst:   mostly DIY.  port of /arch/quickinst

dieter/automatic: unofficial. not enabled by default


** Contributing **
Install a VM (I use virtualbox-ose, works fine), make a vm, boot the install
cd (only i686 works in vbox) and just follow the HOWTO.
It's probably easiest if you set up your own git clone that you can easily
acces from the VM (You can open a github account and for my code).
You can edit on the cd itself, but given the low resolution of the VM and the limited
choice of editors, you'll probably edit on your pc, commit, push to github
and pull from the clone on the cd.
If you want to do debugging, just call the debug function and export DEBUG=1
before calling the scripts.
Keep in mind there are 3 kinds of variables.  Those that affect/belong to
the runtime (install cd live environment), target (affects/belongs to the
target installation) and TMP (everything in between or extra). Variablenames
should have _TARGET or _TMP suffixes or none for runtime.  (Honestly though,
it isn't always the case like that now, I need to do more refactoring)


Much of the code in the core module is taken (and modified) from the 'real' arch linux install
scripts code. (/arch/setup and /arch/quickinst). the modifications are mostly done
to make the code more (re)useable and to separate backend code, user
interface and flow control.  (intro libraries and procedures).  (which was tightly coupled in the original scripts)

I couldn't find what license the code is under, but I assume this
is okay.. if not let me know.
The original code is at
http://projects.archlinux.org/?p=installer.git;a=summary
